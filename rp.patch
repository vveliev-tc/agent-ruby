diff --git a/.rubocop.yml b/.rubocop.yml
index a264eed..d98aadf 100644
--- a/.rubocop.yml
+++ b/.rubocop.yml
@@ -2,6 +2,3 @@ inherit_from: .rubocop_todo.yml
 
 AllCops:
   TargetRubyVersion: 2.3
-
-Metrics/ModuleLength:
-  Enabled: false
diff --git a/.rubocop_todo.yml b/.rubocop_todo.yml
index 3ed4404..ac8c024 100644
--- a/.rubocop_todo.yml
+++ b/.rubocop_todo.yml
@@ -1,59 +1,155 @@
 # This configuration was generated by
 # `rubocop --auto-gen-config`
-# on 2019-09-05 19:40:39 +0200 using RuboCop version 0.71.0.
+# on 2019-07-01 15:09:18 +0200 using RuboCop version 0.69.0.
 # The point is for the user to remove these configuration records
 # one by one as the offenses are removed from the code base.
 # Note that changes in the inspected code, or installation of new
 # versions of RuboCop, may require this file to be generated again.
 
-# Offense count: 13
-Metrics/AbcSize:
-  Max: 34
+# Offense count: 2
+# Cop supports --auto-correct.
+Layout/EmptyLineAfterGuardClause:
+  Exclude:
+    - 'lib/report_portal/cucumber/json_slurper.rb'
+    - 'tests/features/step_definitions/steps.rb'
+
+# Offense count: 5
+# Cop supports --auto-correct.
+# Configuration parameters: EnforcedStyle, EnforcedStyleForEmptyBraces.
+# SupportedStyles: space, no_space, compact
+# SupportedStylesForEmptyBraces: space, no_space
+Layout/SpaceInsideHashLiteralBraces:
+  Exclude:
+    - 'lib/reportportal.rb'
+    - 'tests/formatter_spec.rb'
 
 # Offense count: 1
+Lint/ParenthesesAsGroupedExpression:
+  Exclude:
+    - 'tests/features/step_definitions/steps.rb'
+
+# Offense count: 1
+# Cop supports --auto-correct.
+Lint/UnneededRequireStatement:
+  Exclude:
+    - 'lib/report_portal/cucumber/formatter.rb'
+
+# Offense count: 2
+Lint/UriEscapeUnescape:
+  Exclude:
+    - 'lib/reportportal.rb'
+
+# Offense count: 18
+Metrics/AbcSize:
+  Max: 106
+
+# Offense count: 5
 # Configuration parameters: CountComments, ExcludedMethods.
 # ExcludedMethods: refine
 Metrics/BlockLength:
-  Max: 27
+  Max: 74
 
-# Offense count: 1
+# Offense count: 2
 # Configuration parameters: CountComments.
 Metrics/ClassLength:
-  Max: 169
+  Max: 350
 
-# Offense count: 2
+# Offense count: 3
 Metrics/CyclomaticComplexity:
-  Max: 9
+  Max: 13
 
-# Offense count: 16
+# Offense count: 19
 # Configuration parameters: CountComments, ExcludedMethods.
 Metrics/MethodLength:
-  Max: 33
+  Max: 79
 
-# Offense count: 4
+# Offense count: 1
+# Configuration parameters: CountComments.
+Metrics/ModuleLength:
+  Max: 250
+
+
+# Offense count: 5
 Metrics/PerceivedComplexity:
-  Max: 10
+  Max: 14
+
+# Offense count: 3
+# Configuration parameters: MinNameLength, AllowNamesEndingInNumbers, AllowedNames, ForbiddenNames.
+# AllowedNames: io, id, to, by, on, in, at, ip, db
+Naming/UncommunicativeMethodParamName:
+  Exclude:
+    - 'lib/report_portal/patches/rest_client.rb'
+
+# Offense count: 1
+# Cop supports --auto-correct.
+Security/YAMLLoad:
+  Exclude:
+    - 'lib/report_portal/settings.rb'
 
-# Offense count: 7
+# Offense count: 1
+# Cop supports --auto-correct.
+# Configuration parameters: EnforcedStyle.
+# SupportedStyles: braces, no_braces, context_dependent
+Style/BracesAroundHashParameters:
+  Exclude:
+    - 'tests/formatter_spec.rb'
+
+# Offense count: 1
+Style/CommentedKeyword:
+  Exclude:
+    - 'lib/report_portal/cucumber/report.rb'
+
+# Offense count: 2
+# Cop supports --auto-correct.
+# Configuration parameters: EnforcedStyle, SingleLineConditionsOnly, IncludeTernaryExpressions.
+# SupportedStyles: assign_to_condition, assign_inside_condition
+Style/ConditionalAssignment:
+  Exclude:
+    - 'lib/reportportal.rb'
+
+# Offense count: 9
 Style/Documentation:
   Exclude:
     - 'spec/**/*'
     - 'test/**/*'
     - 'lib/report_portal/cucumber/formatter.rb'
-    - 'lib/report_portal/cucumber/parallel_formatter.rb'
-    - 'lib/report_portal/cucumber/parallel_report.rb'
     - 'lib/report_portal/logging/logger.rb'
+    - 'lib/report_portal/patches/rest_client.rb'
     - 'lib/report_portal/rspec/formatter.rb'
     - 'lib/report_portal/settings.rb'
     - 'lib/reportportal.rb'
 
+# Offense count: 2
+# Cop supports --auto-correct.
+# Configuration parameters: EnforcedStyle.
+# SupportedStyles: empty, nil, both
+Style/EmptyElse:
+  Exclude:
+    - 'lib/report_portal/cucumber/json_slurper.rb'
+    - 'lib/reportportal.rb'
+
+# Offense count: 2
+# Cop supports --auto-correct.
+Style/ExpandPathArguments:
+  Exclude:
+    - 'Rakefile'
+    - 'reportportal.gemspec'
+
+# Offense count: 2
+# Cop supports --auto-correct.
+# Configuration parameters: EnforcedStyle.
+# SupportedStyles: format, sprintf, percent
+Style/FormatString:
+  Exclude:
+    - 'lib/report_portal/cucumber/report.rb'
+
 # Offense count: 5
 # Configuration parameters: .
 # SupportedStyles: annotated, template, unannotated
 Style/FormatStringToken:
   EnforcedStyle: unannotated
 
-# Offense count: 19
+# Offense count: 21
 # Cop supports --auto-correct.
 # Configuration parameters: EnforcedStyle.
 # SupportedStyles: always, never
@@ -67,11 +163,10 @@ Style/GlobalVars:
     - 'tests/features/step_definitions/steps.rb'
     - 'tests/features/support/env.rb'
 
-# Offense count: 9
+# Offense count: 8
 # Configuration parameters: MinBodyLength.
 Style/GuardClause:
   Exclude:
-    - 'lib/report_portal/cucumber/parallel_report.rb'
     - 'lib/report_portal/cucumber/report.rb'
     - 'lib/report_portal/rspec/formatter.rb'
     - 'lib/reportportal.rb'
@@ -79,14 +174,128 @@ Style/GuardClause:
 
 # Offense count: 3
 # Cop supports --auto-correct.
+# Configuration parameters: EnforcedStyle, UseHashRocketsWithSymbolValues, PreferHashRocketsForNonAlnumEndingSymbols.
+# SupportedStyles: ruby19, hash_rockets, no_mixed_keys, ruby19_no_mixed_keys
+Style/HashSyntax:
+  Exclude:
+    - 'lib/reportportal.rb'
+    - 'tests/formatter_spec.rb'
+
+# Offense count: 5
+# Cop supports --auto-correct.
 Style/IfUnlessModifier:
   Exclude:
+    - 'lib/report_portal/cucumber/json_slurper.rb'
     - 'lib/report_portal/cucumber/report.rb'
     - 'tests/features/support/env.rb'
 
-# Offense count: 79
+# Offense count: 1
+# Cop supports --auto-correct.
+# Configuration parameters: EnforcedStyle, Autocorrect.
+# SupportedStyles: module_function, extend_self
+Style/ModuleFunction:
+  Exclude:
+    - 'lib/report_portal/patches/rest_client.rb'
+
+# Offense count: 3
+# Cop supports --auto-correct.
+# Configuration parameters: EnforcedStyle.
+# SupportedStyles: literals, strict
+Style/MutableConstant:
+  Exclude:
+    - 'lib/report_portal/settings.rb'
+    - 'lib/report_portal/version.rb'
+    - 'lib/reportportal.rb'
+
+# Offense count: 1
+# Cop supports --auto-correct.
+# Configuration parameters: AutoCorrect, EnforcedStyle, IgnoredMethods.
+# SupportedStyles: predicate, comparison
+Style/NumericPredicate:
+  Exclude:
+    - 'spec/**/*'
+    - 'lib/report_portal/cucumber/formatter.rb'
+
+# Offense count: 1
+# Cop supports --auto-correct.
+# Configuration parameters: PreferredDelimiters.
+Style/PercentLiteralDelimiters:
+  Exclude:
+    - 'lib/report_portal/cucumber/json_slurper.rb'
+
+# Offense count: 1
+# Cop supports --auto-correct.
+# Configuration parameters: EnforcedStyle.
+# SupportedStyles: implicit, explicit
+Style/RescueStandardError:
+  Exclude:
+    - 'lib/reportportal.rb'
+
+# Offense count: 2
+# Cop supports --auto-correct.
+# Configuration parameters: ConvertCodeThatCanStartToReturnNil, Whitelist.
+# Whitelist: present?, blank?, presence, try, try!
+Style/SafeNavigation:
+  Exclude:
+    - 'lib/report_portal/cucumber/json_slurper.rb'
+    - 'lib/reportportal.rb'
+
+# Offense count: 10
+# Cop supports --auto-correct.
+# Configuration parameters: EnforcedStyle.
+# SupportedStyles: only_raise, only_fail, semantic
+Style/SignalException:
+  Exclude:
+    - 'lib/report_portal/cucumber/json_slurper.rb'
+    - 'lib/report_portal/settings.rb'
+    - 'tests/features/step_definitions/steps.rb'
+    - 'tests/features/support/env.rb'
+    - 'tests/spec/test_spec.rb'
+
+# Offense count: 3
+# Cop supports --auto-correct.
+# Configuration parameters: EnforcedStyle.
+# SupportedStyles: use_perl_names, use_english_names
+Style/SpecialGlobalVars:
+  Exclude:
+    - 'lib/reportportal.rb'
+
+# Offense count: 2
+# Cop supports --auto-correct.
+# Configuration parameters: EnforcedStyle, ConsistentQuotesInMultiline.
+# SupportedStyles: single_quotes, double_quotes
+Style/StringLiterals:
+  Exclude:
+    - 'lib/report_portal/cucumber/report.rb'
+    - 'lib/report_portal/tasks.rb'
+
+# Offense count: 4
+# Cop supports --auto-correct.
+# Configuration parameters: MinSize.
+# SupportedStyles: percent, brackets
+Style/SymbolArray:
+  EnforcedStyle: brackets
+
+# Offense count: 2
+# Cop supports --auto-correct.
+# Configuration parameters: EnforcedStyle, AllowSafeAssignment.
+# SupportedStyles: require_parentheses, require_no_parentheses, require_parentheses_when_complex
+Style/TernaryParentheses:
+  Exclude:
+    - 'lib/report_portal/cucumber/report.rb'
+    - 'lib/report_portal/rspec/formatter.rb'
+
+# Offense count: 1
+# Cop supports --auto-correct.
+# Configuration parameters: EnforcedStyleForMultiline.
+# SupportedStylesForMultiline: comma, consistent_comma, no_comma
+Style/TrailingCommaInHashLiteral:
+  Exclude:
+    - 'lib/report_portal/settings.rb'
+
+# Offense count: 104
 # Cop supports --auto-correct.
 # Configuration parameters: AutoCorrect, AllowHeredoc, AllowURI, URISchemes, IgnoreCopDirectives, IgnoredPatterns.
 # URISchemes: http, https
 Metrics/LineLength:
-  Max: 192
+  Max: 164
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 2c061d9..43e4b3a 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -3,11 +3,3 @@
 ## In Git (not released)
 
 * reportportal/reportportal#293 - Re-licence client side to Apache 2.0
-* Remove multipart monkeypatch of RestClient. Replace RestClient with HTTP gem as it supports multipart fine
-* Make `/api/v1` not required as part of endpoint in report_portal.yml
-* Add a mode to use persistent HTTP connection
-* Remove JSON slurper
-* Support environment variable names prefixed with `rp_` in `reportportal:start_launch` and `reportportal:finish_launch` for consistency with formatters
-* Support providing configuration values via upcased environment variables (e.g. `RP_UUID`)
-* Report real, not mocked time when Timecop is used
-* Add commands to modify/search/delete test items
diff --git a/Gemfile b/Gemfile
index e45c32c..86a906a 100644
--- a/Gemfile
+++ b/Gemfile
@@ -3,10 +3,11 @@ source 'https://rubygems.org'
 gemspec
 
 gem 'cucumber', '~> 3'
-gem 'parallel_tests'
-gem 'rake'
-gem 'rspec'
-gem 'rubytree', git: 'https://github.com/razboev/RubyTree'
-
+gem 'faraday'
 gem 'log4r'
 gem 'logging'
+gem 'parallel_tests', '~> 2.15.0'
+gem 'rake'
+gem 'rspec'
+gem 'rubytree'
+gem 'sys-proctable', '~> 1.1.5'
diff --git a/README.md b/README.md
index b3f8852..986125c 100644
--- a/README.md
+++ b/README.md
@@ -28,12 +28,18 @@ Add `gem 'reportportal', git: 'https://github.com/reportportal/agent-ruby.git'`
 
 * With Cucumber:
 
-```cucumber <other options> -f ReportPortal::Cucumber::Formatter```
+```cucumber <other options> -f ReportPortal::Cucumber::Formatter -o '<log_file>'```
 
-* With Cucumber and parallel_tests gem:
-
-```parallel_cucumber <some options> -o '<some other options> -f ReportPortal::Cucumber::ParallelFormatter'```
+* With Cucumber (Advanced)
 
+```ruby
+AfterConfiguration do |config|
+  ...
+  #rp_log_file = <Generated or from ENV>
+  ...
+  config.formats.push(["ReportPortal::Cucumber::Formatter", {}, rp_log_file])
+end 
+```
 * With RSpec:
 
 ```rspec <other options> -f ReportPortal::RSpec::Formatter```
@@ -54,15 +60,16 @@ Supported settings:
  - launch_id - id of previously created launch (to be used if formatter_modes contains attach_to_launch)
  - file_with_launch_id - path to file with id of launch (to be used if formatter_modes contains attach_to_launch)
  - disable_ssl_verification - set to true to disable SSL verification on connect to ReportPortal (potential security hole!). Set `disable_ssl_verification` to `true` if you see the following error:
+ - launch_uuid - when formatter_modes contains `attach_to_launch`, launch_uuid will be used to create uniq report group (tmp dir should be shared across all launches)
+ - log_level - this is log level for report_portal agent (useful for troubleshooting issues when run in parallel mode)
 ```
 Request to https://rp.epam.com/reportportal-ws/api/v1/pass-team/launch//finish produced an exception: RestClient::SSLCertificateNotVerified: SSL_connect returned=1 errno=0 state=SSLv3 read server certificate B: certificate verify failed
 ```
  - is_debug - set to true to mark the launch as 'DEBUG' (it will appear in Debug tab in Report Portal)
  - use_standard_logger - set to true to enable logging via standard Ruby Logger class to ReportPortal. Note that log messages are transformed to strings before sending.
 
-Each of these settings can be overridden by an environment variable with the same name and 'rp_' prefix (e.g. 'rp_uuid' for 'uuid'). Environment variable can be upper cased (e.g. 'RP_UUID').
-Environment variables take precedence over YAML configuration.
-Environment variable values are parsed as YAML values.
+Each of these settings can be overridden by an environment variable with the same name and 'rp_' prefix (e.g. 'rp_uuid' for 'uuid'). Environment variables take precedence over YAML configuration.
+Environment variable values are parsed as YAML entities.
 
 ## WebMock configuration
 If you use WebMock for stubbing and setting expectations on HTTP requests in Ruby,
@@ -76,13 +83,36 @@ WebMock.disable_net_connect!(:net_http_connect_on_start => true, :allow_localhos
 ## Formatter modes
 
 The following modes are supported:
-
-| Name | Purpose |
-| --- | --- |
-| attach_to_launch | Do not create a new launch but add executing features/scenarios to an existing launch. Use launch_id or file_with_launch_id settings to configure that. If they are not present client will check rp_launch_id.tmp in `Dir.tmpdir`)
-| use_same_thread_for_reporting | Send reporting commands in the same main thread used for running tests. This mode is useful for debugging this Report Portal client. It changes default behavior to send commands in the separate thread. Default behavior is there not to slow test execution. |
-| skip_reporting_hierarchy | Do not create items for folders and feature files |
-| use_persistent_connection | Use persistent connection to connect to the server |
+<table><thead><tr><th>Name</th><th>Purpose</th></tr></thead>
+<tbody>
+<tr>
+<td>attach_to_launch</td>
+<td>
+Add executing features/scenarios to same launch. 
+Use following options are available to configure that. 
+
+    1. launch_id
+    2. file_with_launch_id 
+    3. launch_uuid
+    4. rp_launch_id_for_<first process pid>.lock in `Dir.tmpdir` 
+    
+    *** If launch is not created, cucumber process will create one. Such that user does not need to worry about creating new launch.
+</td>
+</tr>
+<tr>
+<td>use_same_thread_for_reporting</td>
+<td>
+Send reporting commands in the same main thread used for running tests. This mode is useful for debugging 
+Report Portal client. It changes default behavior to send commands in the separate thread.
+Default behavior is there not to slow test execution. </td>
+</tr>
+<tr>
+<td>skip_reporting_hierarchy</td>
+<td>
+Do not create items for folders and feature files</td>
+</tr>
+</tbody>
+</table>
 
 ## Logging
 Experimental support for three common logging frameworks was added:
@@ -93,12 +123,6 @@ Experimental support for three common logging frameworks was added:
 
 To use Logger, set use_standard_logger parameter to true (see Configuration chapter). For the other two corresponding appenders/outputters are available under reportportal/logging.
 
-## Parallel formatter
-
-ReportPortal::Cucumber::ParallelFormatter can be used for tests started via parallel_tests gem.
-
-Note: Launch id is shared between independent processes (as is the case with parallel_tests gem) via a file in `Dir.tmpdir`.
-
 ## Links
 
  - [ReportPortal](https://github.com/reportportal/)
diff --git a/Rakefile b/Rakefile
index 5f14a0c..98e5178 100644
--- a/Rakefile
+++ b/Rakefile
@@ -1,4 +1,4 @@
-lib = File.expand_path('lib', __dir__)
+lib = File.expand_path('../lib', __FILE__)
 $LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)
 
 # used for testing purposes
diff --git a/config/report_portal.yaml.example b/config/report_portal.yaml.example
index 5d1afc7..317bb26 100644
--- a/config/report_portal.yaml.example
+++ b/config/report_portal.yaml.example
@@ -1,5 +1,5 @@
 uuid: 12345678-1234-1234-1234-123456789012
-endpoint: https://localhost:8080
+endpoint: https://localhost:8080/api/v1
 launch: example_launch_name
 project: default_personal
 tags: [tag1, tag2, tag3]
diff --git a/lib/report_portal/client.rb b/lib/report_portal/client.rb
new file mode 100644
index 0000000..297759f
--- /dev/null
+++ b/lib/report_portal/client.rb
@@ -0,0 +1,52 @@
+module ReportPortal
+  # @api private
+  class Client
+    attr_accessor :logger
+
+    def initialize(logger)
+      @logger = logger
+    end
+
+    def process_request(path, method, *options)
+      tries = 2
+      begin
+        response = rp_client.send(method, path, *options)
+      rescue Faraday::ClientError => e
+        logger.error("TRACE[#{e.backtrace}]")
+        response = JSON.parse(e.response[:body])
+        logger.warn("Exception[#{e}], response:[#{response}]], retry_count: [#{tries}]")
+        m = response['message'].match(%r{Start time of child \['(.+)'\] item should be same or later than start time \['(.+)'\] of the parent item\/launch '.+'})
+        case response['error_code']
+        when 4001
+          return
+        end
+
+        if m
+          parent_time = Time.strptime(m[2], '%a %b %d %H:%M:%S %z %Y')
+          data = JSON.parse(options[0])
+          logger.warn("RP error : 40025, time of a child: [#{data['start_time']}], paren time: [#{(parent_time.to_f * 1000).to_i}]")
+          data['start_time'] = (parent_time.to_f * 1000).to_i + 1000
+          options[0] = data.to_json
+          ReportPortal.last_used_time = data['start_time']
+        end
+
+        retry unless (tries -= 1).zero?
+      end
+      JSON.parse(response.body)
+    end
+
+    def rp_client
+      @connection ||= Faraday.new(url: Settings.instance.project_url, request: { timeout: 300 }) do |f|
+        f.headers = { Authorization: "Bearer #{Settings.instance.uuid}", Accept: 'application/json', 'Content-type': 'application/json' }
+        verify_ssl = Settings.instance.disable_ssl_verification
+        f.ssl.verify = !verify_ssl unless verify_ssl.nil?
+        f.request :multipart
+        f.request :url_encoded
+        f.response :raise_error
+        f.adapter :net_http_persistent
+      end
+
+      @connection
+    end
+  end
+end
diff --git a/lib/report_portal/cucumber/formatter.rb b/lib/report_portal/cucumber/formatter.rb
index 8c4d13b..0afb37c 100644
--- a/lib/report_portal/cucumber/formatter.rb
+++ b/lib/report_portal/cucumber/formatter.rb
@@ -1,3 +1,5 @@
+require 'thread'
+
 require_relative 'report'
 
 module ReportPortal
@@ -5,13 +7,11 @@ module ReportPortal
     class Formatter
       # @api private
       def initialize(config)
-        ENV['REPORT_PORTAL_USED'] = 'true'
-
+        @logger = Logger.new(config.out_stream)
+        @logger.level = ReportPortal::Settings.instance.log_level || :warn
         setup_message_processing
 
-        @io = config.out_stream
-
-        %i[test_case_started test_case_finished test_step_started test_step_finished test_run_finished].each do |event_name|
+        [:test_case_started, :test_case_finished, :test_step_started, :test_step_finished, :test_run_finished].each do |event_name|
           config.on_event event_name do |event|
             process_message(event_name, event)
           end
@@ -21,8 +21,6 @@ module ReportPortal
 
       def puts(message)
         process_message(:puts, message)
-        @io.puts(message)
-        @io.flush
       end
 
       def embed(*args)
@@ -32,7 +30,7 @@ module ReportPortal
       private
 
       def report
-        @report ||= ReportPortal::Cucumber::Report.new
+        @report ||= ReportPortal::Cucumber::Report.new(@logger)
       end
 
       def setup_message_processing
@@ -51,7 +49,7 @@ module ReportPortal
       def finish_message_processing
         return if use_same_thread_for_reporting?
 
-        sleep 0.03 while !@queue.empty? || @queue.num_waiting.zero? # TODO: how to interrupt launch if the user aborted execution
+        sleep 0.03 while !@queue.empty? || @queue.num_waiting == 0 # TODO: how to interrupt launch if the user aborted execution
         @thread.kill
       end
 
diff --git a/lib/report_portal/cucumber/json_slurper.rb b/lib/report_portal/cucumber/json_slurper.rb
new file mode 100644
index 0000000..b2bcf85
--- /dev/null
+++ b/lib/report_portal/cucumber/json_slurper.rb
@@ -0,0 +1,159 @@
+require 'base64'
+require 'securerandom'
+require 'mime/types'
+
+require_relative '../../reportportal'
+require_relative '../settings'
+
+module ReportPortal
+  module Cucumber
+    # Helper class to parse and post test launch data generated by Cucumber's JSON formatter
+    # Supports ONLY reports generated with -x switch (i.e. expanded outlines)
+    class JSONSlurper
+      def initialize(filename)
+        @json = JSON.parse(File.read(filename))
+        fail "Cannot process #{filename} because it was generated without -x/--expand Cucumber option!" unless expanded?
+        calculate_start_time
+      end
+
+      def run
+        ReportPortal.start_launch('', get_time)
+
+        @json.each do |feature|
+          current_feature = ReportPortal::TestItem.new("Feature: #{feature['name']}",
+                                                       :TEST,
+                                                       nil,
+                                                       get_time,
+                                                       feature['uri'],
+                                                       nil,
+                                                       tags(feature))
+          current_feature_node = Tree::TreeNode.new(SecureRandom.hex, current_feature)
+          current_feature.id = ReportPortal.start_item(current_feature_node)
+          current_element_name = nil
+          current_outline_row = 0
+
+          feature['elements'].each do |element|
+            type = element['type'] == 'background' ? :BEFORE_CLASS : :STEP
+
+            element_name = "#{element['keyword']}: #{element['name']}"
+            if element['keyword'] == 'Scenario Outline'
+              if element['name'] == current_element_name
+                current_outline_row += 1
+              else
+                current_element_name = element['name']
+                current_outline_row = 1
+              end
+              element_name << " [#{current_outline_row}]"
+            end
+
+            ReportPortal.current_scenario = ReportPortal::TestItem.new(element_name,
+                                                                       type,
+                                                                       nil,
+                                                                       get_time,
+                                                                       "#{feature['uri']}:#{element['line']}",
+                                                                       nil,
+                                                                       tags(element))
+            current_scenario_node = Tree::TreeNode.new(SecureRandom.hex, ReportPortal.current_scenario)
+            ReportPortal.current_scenario.id = ReportPortal.start_item(current_scenario_node)
+
+            statuses = report_hooks(element, 'before')
+            forced_issue = nil
+            element['steps'].each do |step|
+              name = decorate("#{step['keyword']}#{step['name']}")
+              if step['rows']
+                name << step['rows'].reduce("\n") { |acc, row| acc << decorate("| #{row['cells'].join(' | ')} |") << "\n" }
+              end
+              if step['doc_string']
+                name << %(\n"""\n#{step['doc_string']['value']}\n""")
+              end
+
+              ReportPortal.send_log(:passed, name, get_time)
+              step['output'].each { |o| ReportPortal.send_log(:passed, o, get_time) } unless step['output'].nil?
+              error = step['result']['error_message']
+              ReportPortal.send_log(:failed, error, get_time) if error
+              (step['embeddings'] || []).each do |embedding|
+                ReportPortal.send_file(:failed, embedding['data'], 'Embedding', get_time, embedding['mime_type'])
+              end
+              statuses << step['result']['status']
+              forced_issue ||= case step['result']['status']
+                               when 'pending'
+                                 error
+                               when 'undefined'
+                                 "Undefined step #{step['name']} at #{step['match']['location']}"
+                               else
+                                 nil
+                               end
+
+              ReportPortal.send_log(step['result']['status'].to_sym,
+                                    "STEP #{step['result']['status'].upcase}",
+                                    get_time(step['result']['duration'].to_i / 1_000_000))
+            end
+            statuses += report_hooks(element, 'after')
+
+            status = if statuses.any? { |s| %w(failed undefined pending).include? s }
+                       :failed
+                     elsif statuses.all? { |s| s == 'passed' }
+                       :passed
+                     else
+                       :skipped
+                     end
+
+            ReportPortal.finish_item(ReportPortal.current_scenario, status, get_time, forced_issue)
+            ReportPortal.current_scenario = nil
+          end
+
+          ReportPortal.finish_item(current_feature, nil, get_time)
+        end
+        ReportPortal.finish_item(root, nil, get_time)
+        ReportPortal.finish_launch(get_time)
+      end
+
+      private
+
+      def tags(item)
+        item['tags'].nil? ? [] : item['tags'].map { |h| h['name'] }
+      end
+
+      def decorate(str)
+        sep = '-' * 25
+        "#{sep}#{str}#{sep}"
+      end
+
+      def expanded?
+        bad_item = @json.find do |f|
+          so = f['elements'].find { |e| e['keyword'] == 'Scenario Outline' }
+          so ? so.key?('examples') : false
+        end
+        bad_item.nil?
+      end
+
+      def calculate_start_time
+        duration_nanos = 0
+        @json.each do |f|
+          f['elements'].each do |e|
+            items = e['steps'] + (e['before'] || []) + (e['after'] || [])
+            items.each do |s|
+              duration_nanos += s['result']['duration'].to_i
+            end
+          end
+        end
+        @now = (Time.now.to_f * 1000).to_i - (duration_nanos / 1_000_000)
+      end
+
+      # update current time and return
+      def get_time(offset = 0)
+        @now += offset + 1
+      end
+
+      # report before/after hooks and return array of their statuses
+      def report_hooks(element, tag)
+        (element[tag] || []).map do |hook|
+          ReportPortal.send_log(hook['result']['status'].to_sym,
+                                "HOOK #{hook['match']['location']} #{hook['result']['status'].upcase}",
+                                get_time(hook['result']['duration'].to_i / 1_000_000))
+          hook['result']['status']
+        end
+      end
+    end
+  end
+end
diff --git a/lib/report_portal/cucumber/parallel_formatter.rb b/lib/report_portal/cucumber/parallel_formatter.rb
deleted file mode 100644
index a769685..0000000
--- a/lib/report_portal/cucumber/parallel_formatter.rb
+++ /dev/null
@@ -1,14 +0,0 @@
-require_relative 'formatter'
-require_relative 'parallel_report'
-
-module ReportPortal
-  module Cucumber
-    class ParallelFormatter < Formatter
-      private
-
-      def report
-        @report ||= ReportPortal::Cucumber::ParallelReport.new
-      end
-    end
-  end
-end
diff --git a/lib/report_portal/cucumber/parallel_report.rb b/lib/report_portal/cucumber/parallel_report.rb
deleted file mode 100644
index f1648e3..0000000
--- a/lib/report_portal/cucumber/parallel_report.rb
+++ /dev/null
@@ -1,54 +0,0 @@
-require 'parallel_tests'
-
-require_relative 'report'
-
-module ReportPortal
-  module Cucumber
-    class ParallelReport < Report
-      FILE_WITH_LAUNCH_ID = Pathname(Dir.tmpdir) + "parallel_launch_id_for_#{Process.ppid}.lck"
-
-      def parallel?
-        true
-      end
-
-      def initialize
-        @root_node = Tree::TreeNode.new('')
-        @parent_item_node = @root_node
-        @last_used_time ||= 0
-
-        if ParallelTests.first_process?
-          File.open(FILE_WITH_LAUNCH_ID, 'w') do |f|
-            f.flock(File::LOCK_EX)
-            start_launch
-            f.write(ReportPortal.launch_id)
-            f.flush
-            f.flock(File::LOCK_UN)
-          end
-        else
-          File.open(FILE_WITH_LAUNCH_ID, 'r') do |f|
-            f.flock(File::LOCK_SH)
-            ReportPortal.launch_id = f.read
-            f.flock(File::LOCK_UN)
-          end
-        end
-      end
-
-      def test_run_finished(_event, desired_time = ReportPortal.now)
-        end_feature(desired_time) unless @parent_item_node.is_root?
-
-        if ParallelTests.first_process?
-          ParallelTests.wait_for_other_processes_to_finish
-
-          File.delete(FILE_WITH_LAUNCH_ID)
-
-          unless attach_to_launch?
-            $stdout.puts "Finishing launch #{ReportPortal.launch_id}"
-            ReportPortal.close_child_items(nil)
-            time_to_send = time_to_send(desired_time)
-            ReportPortal.finish_launch(time_to_send)
-          end
-        end
-      end
-    end
-  end
-end
diff --git a/lib/report_portal/cucumber/report.rb b/lib/report_portal/cucumber/report.rb
index f331c2e..b82266b 100644
--- a/lib/report_portal/cucumber/report.rb
+++ b/lib/report_portal/cucumber/report.rb
@@ -1,7 +1,9 @@
-require 'cucumber/formatter/io'
-require 'cucumber/formatter/hook_query_visitor'
 require 'tree'
 require 'securerandom'
+require 'tempfile'
+require 'parallel_tests'
+require 'sys/proctable'
+require 'fileutils'
 
 require_relative '../../reportportal'
 require_relative '../logging/logger'
@@ -10,40 +12,89 @@ module ReportPortal
   module Cucumber
     # @api private
     class Report
-      def parallel?
-        false
-      end
+      attr_accessor :parallel, :started_launch
 
       def attach_to_launch?
         ReportPortal::Settings.instance.formatter_modes.include?('attach_to_launch')
       end
 
-      def initialize
-        @last_used_time = 0
+      def initialize(logger)
+        @logger = logger
+        ReportPortal.last_used_time = 0
+        ReportPortal.initialize(logger)
         @root_node = Tree::TreeNode.new('')
         @parent_item_node = @root_node
-        start_launch
+
+        set_parallel_tests_vars
+
+        if ParallelTests.first_process?
+          @logger.debug("First process: #{@pid_of_parallel_tests}")
+          start_launch(ReportPortal.now)
+        else
+          @logger.debug("Child process: #{@pid_of_parallel_tests}")
+          start_time = monotonic_time
+          loop do
+            break if File.exist?(lock_file)
+            if monotonic_time - start_time > wait_time_for_launch_create
+              raise "File with launch ID wasn't created after waiting #{wait_time_for_launch_create} seconds"
+            end
+
+            @logger.debug "File with launch ID wasn't created after waiting #{monotonic_time - start_time} seconds"
+
+            sleep 0.5
+          end
+          ReportPortal.launch_id = read_lock_file(lock_file)
+          @logger.debug "Attaching to launch using lock_file [#{lock_file}], launch_id: [#{ReportPortal.launch_id}] "
+          add_process_description
+        end
       end
 
-      def start_launch(desired_time = ReportPortal.now)
+      def start_launch(desired_time, cmd_args = ARGV)
         if attach_to_launch?
           ReportPortal.launch_id =
             if ReportPortal::Settings.instance.launch_id
               ReportPortal::Settings.instance.launch_id
             else
-              file_path = ReportPortal::Settings.instance.file_with_launch_id || (Pathname(Dir.tmpdir) + 'rp_launch_id.tmp')
-              File.read(file_path)
+              file_path = lock_file
+              if File.file?(file_path)
+                read_lock_file(file_path)
+              else
+                self.started_launch = true
+                new_launch(desired_time, cmd_args, file_path)
+              end
             end
-          $stdout.puts "Attaching to launch #{ReportPortal.launch_id}"
+          @logger.info "Attaching to launch #{ReportPortal.launch_id}"
         else
-          description = ReportPortal::Settings.instance.description
-          description ||= ARGV.map { |arg| arg.gsub(/rp_uuid=.+/, 'rp_uuid=[FILTERED]') }.join(' ')
-          ReportPortal.start_launch(description, time_to_send(desired_time))
+          new_launch(desired_time, cmd_args)
+        end
+      end
+
+      def new_launch(desired_time, cmd_args = ARGV, lock_file = nil)
+        @logger.info("Creating new launch at: [#{desired_time}], with cmd: [#{cmd_args}] and file lock: [#{lock_file}]")
+        ReportPortal.start_launch(description(cmd_args), time_to_send(desired_time))
+        set_file_lock_with_launch_id(lock_file, ReportPortal.launch_id) if lock_file
+        ReportPortal.launch_id
+      end
+
+      def description(cmd_args = ARGV)
+        description ||= ReportPortal::Settings.instance.description
+        description ||= cmd_args.map { |arg| arg.gsub(/rp_uuid=.+/, "rp_uuid=[FILTERED]") }.join(' ')
+        description
+      end
+
+      def set_file_lock_with_launch_id(lock_file, launch_id)
+        FileUtils.mkdir_p File.dirname(lock_file)
+        File.open(lock_file, 'w') do |f|
+          f.flock(File::LOCK_EX)
+          f.write(launch_id)
+          f.flush
+          f.flock(File::LOCK_UN)
         end
       end
 
-      # TODO: time should be a required argument
-      def test_case_started(event, desired_time = ReportPortal.now)
+      # scenario starts in separate treads
+      def test_case_started(event, desired_time)
+        @logger.debug "test_case_started: [#{event}], "
         test_case = event.test_case
         feature = test_case.feature
         if report_hierarchy? && !same_feature_as_previous_test_case?(feature)
@@ -56,17 +107,18 @@ module ReportPortal
         tags = test_case.tags.map(&:name)
         type = :STEP
 
-        ReportPortal.current_scenario = ReportPortal::TestItem.new(name: name, type: type, id: nil, start_time: time_to_send(desired_time), description: description, closed: false, tags: tags)
+        ReportPortal.current_scenario = ReportPortal::TestItem.new(name, type, nil, time_to_send(desired_time), description, false, tags)
         scenario_node = Tree::TreeNode.new(SecureRandom.hex, ReportPortal.current_scenario)
         @parent_item_node << scenario_node
         ReportPortal.current_scenario.id = ReportPortal.start_item(scenario_node)
       end
 
-      def test_case_finished(event, desired_time = ReportPortal.now)
+      def test_case_finished(event, desired_time)
+        @logger.debug "test_case_finished: [#{event}], "
         result = event.result
         status = result.to_sym
         issue = nil
-        if %i[undefined pending].include?(status)
+        if [:undefined, :pending].include?(status)
           status = :failed
           issue = result.message
         end
@@ -74,7 +126,8 @@ module ReportPortal
         ReportPortal.current_scenario = nil
       end
 
-      def test_step_started(event, desired_time = ReportPortal.now)
+      def test_step_started(event, desired_time)
+        @logger.debug "test_step_started: [#{event}], "
         test_step = event.test_step
         if step?(test_step) # `after_test_step` is also invoked for hooks
           step_source = test_step.source.last
@@ -88,23 +141,23 @@ module ReportPortal
         end
       end
 
-      def test_step_finished(event, desired_time = ReportPortal.now)
+      def test_step_finished(event, desired_time)
         test_step = event.test_step
         result = event.result
         status = result.to_sym
 
-        if %i[failed pending undefined].include?(status)
-          exception_info = if %i[failed pending].include?(status)
+        if [:failed, :pending, :undefined].include?(status)
+          exception_info = if [:failed, :pending].include?(status)
                              ex = result.exception
-                             format("%s: %s\n  %s", ex.class.name, ex.message, ex.backtrace.join("\n  "))
+                             sprintf("%s: %s\n  %s", ex.class.name, ex.message, ex.backtrace.join("\n  "))
                            else
-                             format("Undefined step: %s:\n%s", test_step.text, test_step.source.last.backtrace_line)
+                             sprintf("Undefined step: %s:\n%s", test_step.text, test_step.source.last.backtrace_line)
                            end
           ReportPortal.send_log(:error, exception_info, time_to_send(desired_time))
         end
 
         if status != :passed
-          log_level = status == :skipped ? :warn : :error
+          log_level = (status == :skipped) ? :warn : :error
           step_type = if step?(test_step)
                         'Step'
                       else
@@ -116,25 +169,106 @@ module ReportPortal
         end
       end
 
-      def test_run_finished(_event, desired_time = ReportPortal.now)
+      def test_run_finished(_event, desired_time)
         end_feature(desired_time) unless @parent_item_node.is_root?
+        @logger.info("Test run finish: [#{@parent_item_node}]")
+        close_all_children_of(@root_node) # Folder items are closed here as they can't be closed after finishing a feature
+        if parallel
+          @logger.debug("Parallel process: #{@pid_of_parallel_tests}")
+          if ParallelTests.first_process? && started_launch
+            ParallelTests.wait_for_other_processes_to_finish
+            File.delete(lock_file)
+            @logger.info("close launch , delete lock")
+            complete_launch(desired_time)
+          end
+        else
+          complete_launch(desired_time)
+        end
+      end
+
+      def add_process_description
+        description = ReportPortal.remote_launch['description'].split(' ')
+        description.push(self.description.split(' ')).flatten!
+        ReportPortal.update_launch(description: description.uniq.join(' '))
+      end
 
-        unless attach_to_launch?
-          close_all_children_of(@root_node) # Folder items are closed here as they can't be closed after finishing a feature
+      def puts(message, desired_time)
+        ReportPortal.send_log(:info, message, time_to_send(desired_time))
+      end
+
+      def embed(src, mime_type, label, desired_time)
+        ReportPortal.send_file(:info, src, label, time_to_send(desired_time), mime_type)
+      end
+
+      private
+
+      def complete_launch(desired_time)
+        if started_launch || !attach_to_launch?
           time_to_send = time_to_send(desired_time)
           ReportPortal.finish_launch(time_to_send)
         end
       end
 
-      def puts(message, desired_time = ReportPortal.now)
-        ReportPortal.send_log(:info, message, time_to_send(desired_time))
+      def lock_file(file_path = nil)
+        file_path ||= ReportPortal::Settings.instance.file_with_launch_id
+        @logger.debug("Lock file (RReportPortal::Settings.instance.file_with_launch_id): #{file_path}") if file_path
+        file_path ||= Dir.tmpdir + "/report_portal_#{ReportPortal::Settings.instance.launch_uuid}.lock" if ReportPortal::Settings.instance.launch_uuid
+        @logger.debug("Lock file (ReportPortal::Settings.instance.launch_uuid): #{file_path}") if file_path
+        file_path ||= Dir.tmpdir + "/rp_launch_id_for_#{@pid_of_parallel_tests}.lock" if @pid_of_parallel_tests
+        @logger.debug("Lock file (/rp_launch_id_for_#{@pid_of_parallel_tests}.lock): #{file_path}") if file_path
+
+        file_path
       end
 
-      def embed(path_or_src, mime_type, label, desired_time = ReportPortal.now)
-        ReportPortal.send_file(:info, path_or_src, label, time_to_send(desired_time), mime_type)
+      def set_parallel_tests_vars
+        process_list = Sys::ProcTable.ps
+        @logger.debug("set_test_variables: #{process_list}")
+        runner_process ||= get_parallel_test_process(process_list)
+        @logger.debug("Parallel cucumber runner pid: #{runner_process.pid}") if runner_process
+        runner_process ||= get_cucumber_test_process(process_list)
+        @logger.debug("Cucumber runner pid: #{runner_process.pid}") if runner_process
+        raise 'Failed to find any cucumber related test process' if runner_process.nil?
+
+        @pid_of_parallel_tests = runner_process.pid
       end
 
-      private
+      def get_parallel_test_process(process_list)
+        process_list.each do |process|
+          next unless process.cmdline.match(%r{bin(?:\/|\\)parallel_(?:cucumber|test)(.+)})
+          @parallel = true
+          @logger.debug("get_parallel_test_process: #{process.cmdline}")
+          return process
+        end
+        nil
+      end
+
+      def get_cucumber_test_process(process_list)
+        process_list.each do |process|
+          if process.cmdline.match(%r{bin(?:\/|\\)(?:cucumber)(.+)})
+            @logger.debug("get_cucumber_test_process: #{process.cmdline}")
+            return process
+          end
+        end
+        nil
+      end
+
+      def wait_time_for_launch_create
+        ENV['rp_parallel_launch_wait_time'] || 60
+      end
+
+      def monotonic_time
+        Process.clock_gettime(Process::CLOCK_MONOTONIC)
+      end
+
+      def read_lock_file(file_path)
+        content = nil
+        File.open(file_path, 'r') do |f|
+          f.flock(File::LOCK_SH)
+          content = File.read(file_path)
+          f.flock(File::LOCK_UN)
+        end
+        content
+      end
 
       # Report Portal sorts logs by time. However, several logs might have the same time.
       #   So to get Report Portal sort them properly the time should be different in all logs related to the same item.
@@ -144,10 +278,10 @@ module ReportPortal
       #   * that process/thread can't start the next test until it's done with the previous one
       def time_to_send(desired_time)
         time_to_send = desired_time
-        if time_to_send <= @last_used_time
-          time_to_send = @last_used_time + 1
+        if time_to_send <= ReportPortal.last_used_time
+          time_to_send = ReportPortal.last_used_time + 1
         end
-        @last_used_time = time_to_send
+        ReportPortal.last_used_time = time_to_send
       end
 
       def same_feature_as_previous_test_case?(feature)
@@ -155,6 +289,7 @@ module ReportPortal
       end
 
       def start_feature_with_parentage(feature, desired_time)
+        @logger.debug("start_feature_with_parentage: [#{feature}], [#{desired_time}]")
         parent_node = @root_node
         child_node = nil
         path_components = feature.location.file.split(File::SEPARATOR)
@@ -173,15 +308,15 @@ module ReportPortal
               type = :TEST
             end
             # TODO: multithreading # Parallel formatter always executes scenarios inside the same feature in the same process
-            if parallel? &&
+            if parallel &&
                index < path_components.size - 1 && # is folder?
                (id_of_created_item = ReportPortal.item_id_of(name, parent_node)) # get id for folder from report portal
               # get child id from other process
-              item = ReportPortal::TestItem.new(name: name, type: type, id: id_of_created_item, start_time: time_to_send(desired_time), description: description, closed: false, tags: tags)
+              item = ReportPortal::TestItem.new(name, type, id_of_created_item, time_to_send(desired_time), description, false, tags)
               child_node = Tree::TreeNode.new(path_component, item)
               parent_node << child_node
             else
-              item = ReportPortal::TestItem.new(name: name, type: type, id: nil, start_time: time_to_send(desired_time), description: description, closed: false, tags: tags)
+              item = ReportPortal::TestItem.new(name, type, nil, time_to_send(desired_time), description, false, tags)
               child_node = Tree::TreeNode.new(path_component, item)
               parent_node << child_node
               item.id = ReportPortal.start_item(child_node) # TODO: multithreading
@@ -201,9 +336,22 @@ module ReportPortal
       end
 
       def close_all_children_of(root_node)
+        @logger.debug("close_all_children_of: [#{root_node.children}]")
         root_node.postordered_each do |node|
-          if !node.is_root? && !node.content.closed
-            ReportPortal.finish_item(node.content)
+          @logger.debug("close_all_children_of:postordered_each [#{node.content}]")
+          unless node.is_root? || node.content.closed
+            begin
+              item = ReportPortal.remote_item(node.content[:id])
+              @logger.debug("started_launch?: [#{started_launch}], item details: [#{item}]")
+              if item.key?('end_time')
+                started_launch ? @logger.warn("Main process: item already closed skipping.") : ReportPortal.finish_item(node.content)
+              elsif started_launch
+                ReportPortal.close_child_items(node.content[:id])
+                ReportPortal.finish_item(node.content)
+              else
+                @logger.warn("Child process: item in use cannot close it. [#{item}]")
+              end
+            end
           end
         end
       end
diff --git a/lib/report_portal/event_bus.rb b/lib/report_portal/event_bus.rb
deleted file mode 100644
index dcedbb0..0000000
--- a/lib/report_portal/event_bus.rb
+++ /dev/null
@@ -1,30 +0,0 @@
-require_relative 'events/prepare_start_item_request'
-
-module ReportPortal
-  # @api private
-  class EventBus
-    attr_reader :event_types
-
-    def initialize
-      @event_types = {
-        prepare_start_item_request: Events::PrepareStartItemRequest
-      }
-      @handlers = {}
-    end
-
-    def on(event_name, &proc)
-      handlers_for(event_name) << proc
-    end
-
-    def broadcast(event_name, **attributes)
-      event = event_types.fetch(event_name).new(**attributes)
-      handlers_for(event_name).each { |handler| handler.call(event) }
-    end
-
-    private
-
-    def handlers_for(event_name)
-      @handlers[event_name] ||= []
-    end
-  end
-end
diff --git a/lib/report_portal/events/prepare_start_item_request.rb b/lib/report_portal/events/prepare_start_item_request.rb
deleted file mode 100644
index 146ebb1..0000000
--- a/lib/report_portal/events/prepare_start_item_request.rb
+++ /dev/null
@@ -1,13 +0,0 @@
-module ReportPortal
-  module Events
-    # An event executed before sending a StartTestItem request.
-    class PrepareStartItemRequest
-      # A hash that contains keys like item's `start_time`, `name`, `description`.
-      attr_reader :request_data
-
-      def initialize(request_data:)
-        @request_data = request_data
-      end
-    end
-  end
-end
diff --git a/lib/report_portal/http_client.rb b/lib/report_portal/http_client.rb
deleted file mode 100644
index 55cd64c..0000000
--- a/lib/report_portal/http_client.rb
+++ /dev/null
@@ -1,64 +0,0 @@
-require 'http'
-
-module ReportPortal
-  # @api private
-  class HttpClient
-    def initialize
-      create_client
-    end
-
-    def send_request(verb, path, options = {})
-      path.prepend("/api/v1/#{Settings.instance.project}/")
-      path.prepend(origin) unless use_persistent?
-      3.times do
-        begin
-          response = @http.request(verb, path, options)
-        rescue StandardError => e
-          puts "Request #{request_info(verb, path)} produced an exception:"
-          puts e
-          recreate_client
-        else
-          return response.parse(:json) if response.status.success?
-
-          message = "Request #{request_info(verb, path)} returned code #{response.code}."
-          message << " Response:\n#{response}" unless response.to_s.empty?
-          puts message
-        end
-      end
-    end
-
-    private
-
-    def create_client
-      @http = HTTP.auth("Bearer #{Settings.instance.uuid}")
-      @http = @http.persistent(origin) if use_persistent?
-      add_insecure_ssl_options if Settings.instance.disable_ssl_verification
-    end
-
-    def add_insecure_ssl_options
-      ssl_context = OpenSSL::SSL::SSLContext.new
-      ssl_context.verify_mode = OpenSSL::SSL::VERIFY_NONE
-      @http.default_options = { ssl_context: ssl_context }
-    end
-
-    # Response should be consumed before sending next request via the same persistent connection.
-    # If an exception occurred, there may be no response so a connection has to be recreated.
-    def recreate_client
-      @http.close
-      create_client
-    end
-
-    def request_info(verb, path)
-      uri = URI.join(origin, path)
-      "#{verb.upcase} `#{uri}`"
-    end
-
-    def origin
-      Addressable::URI.parse(Settings.instance.endpoint).origin
-    end
-
-    def use_persistent?
-      ReportPortal::Settings.instance.formatter_modes.include?('use_persistent_connection')
-    end
-  end
-end
diff --git a/lib/report_portal/models/item_search_options.rb b/lib/report_portal/models/item_search_options.rb
deleted file mode 100644
index becc39b..0000000
--- a/lib/report_portal/models/item_search_options.rb
+++ /dev/null
@@ -1,26 +0,0 @@
-module ReportPortal
-  # Options of a request to search items
-  class ItemSearchOptions
-    MAPPING = {
-      launch_id: 'filter.eq.launch',
-      name: 'filter.eq.name',
-      description: 'filter.eq.description',
-      parameter_key: 'filter.eq.parameters$key',
-      parameter_value: 'filter.eq.parameters$value',
-      page_size: 'page.size',
-      page_number: 'page.page'
-    }.freeze
-
-    attr_reader :query_params
-
-    def initialize(params = {})
-      @query_params = params.map { |mapping_key, v| [param_name(mapping_key), v] }.to_h
-    end
-
-    private
-
-    def param_name(mapping_key)
-      MAPPING.fetch(mapping_key) { raise KeyError, "key not found: '#{mapping_key.inspect}'. It should be one of: #{MAPPING.keys}" }
-    end
-  end
-end
diff --git a/lib/report_portal/models/test_item.rb b/lib/report_portal/models/test_item.rb
deleted file mode 100644
index ce87300..0000000
--- a/lib/report_portal/models/test_item.rb
+++ /dev/null
@@ -1,22 +0,0 @@
-module ReportPortal
-  # Represents a test item
-  class TestItem
-    attr_reader :launch_id, :unique_id, :name, :description, :type, :parameters, :tags, :status, :start_time
-    attr_accessor :id, :closed
-
-    def initialize(options = {})
-      options = options.map { |k, v| [k.to_sym, v] }.to_h
-      @launch_id = options[:launch_id]
-      @unique_id = options[:unique_id]
-      @name = options[:name]
-      @description = options[:description]
-      @type = options[:type]
-      @parameters = options[:parameters]
-      @tags = options[:tags]
-      @status = options[:status]
-      @start_time = options[:start_time]
-      @id = options[:id]
-      @closed = options[:closed]
-    end
-  end
-end
diff --git a/lib/report_portal/patches/faraday.rb b/lib/report_portal/patches/faraday.rb
new file mode 100644
index 0000000..2ce6c86
--- /dev/null
+++ b/lib/report_portal/patches/faraday.rb
@@ -0,0 +1,25 @@
+module Faraday
+  class Request
+    # Middleware for supporting multi-part requests.
+    class Multipart
+      def create_multipart(env, params)
+        boundary = env.request.boundary
+        parts = process_params(params) do |key, value|
+          if begin
+            JSON.parse(value)
+             rescue StandardError
+               false
+          end
+            Faraday::Parts::Part.new(boundary, key, value, 'Content-Type' => 'application/json')
+          else
+            Faraday::Parts::Part.new(boundary, key, value)
+          end
+        end
+        parts << Faraday::Parts::EpiloguePart.new(boundary)
+        body = Faraday::CompositeReadIO.new(parts)
+        env.request_headers[Faraday::Env::ContentLength] = body.length.to_s
+        body
+      end
+    end
+  end
+end
diff --git a/lib/report_portal/rspec/formatter.rb b/lib/report_portal/rspec/formatter.rb
index 1d287b7..44b0058 100644
--- a/lib/report_portal/rspec/formatter.rb
+++ b/lib/report_portal/rspec/formatter.rb
@@ -21,7 +21,7 @@ module ReportPortal
       end
 
       def start(_start_notification)
-        cmd_args = ARGV.map { |arg| arg.include?('rp_uuid=') ? 'rp_uuid=[FILTERED]' : arg }.join(' ')
+        cmd_args = ARGV.map { |arg| (arg.include? 'rp_uuid=') ? 'rp_uuid=[FILTERED]' : arg }.join(' ')
         ReportPortal.start_launch(cmd_args)
         @root_node = Tree::TreeNode.new(SecureRandom.hex)
         @current_group_node = @root_node
@@ -33,13 +33,13 @@ module ReportPortal
           p "Group description should be at least #{MIN_DESCRIPTION_LENGTH} characters ('group_notification': #{group_notification.inspect})"
           return
         end
-        item = ReportPortal::TestItem.new(name: description[0..MAX_DESCRIPTION_LENGTH - 1],
-                                          type: :TEST,
-                                          id: nil,
-                                          start_time: ReportPortal.now,
-                                          description: '',
-                                          closed: false,
-                                          tags: [])
+        item = ReportPortal::TestItem.new(description[0..MAX_DESCRIPTION_LENGTH - 1],
+                                          :TEST,
+                                          nil,
+                                          ReportPortal.now,
+                                          '',
+                                          false,
+                                          [])
         group_node = Tree::TreeNode.new(SecureRandom.hex, item)
         if group_node.nil?
           p "Group node is nil for item #{item.inspect}"
@@ -63,13 +63,13 @@ module ReportPortal
           p "Example description should be at least #{MIN_DESCRIPTION_LENGTH} characters ('notification': #{notification.inspect})"
           return
         end
-        ReportPortal.current_scenario = ReportPortal::TestItem.new(name: description[0..MAX_DESCRIPTION_LENGTH - 1],
-                                                                   type: :STEP,
-                                                                   id: nil,
-                                                                   start_time: ReportPortal.now,
-                                                                   description: '',
-                                                                   closed: false,
-                                                                   tags: [])
+        ReportPortal.current_scenario = ReportPortal::TestItem.new(description[0..MAX_DESCRIPTION_LENGTH - 1],
+                                                                   :STEP,
+                                                                   nil,
+                                                                   ReportPortal.now,
+                                                                   '',
+                                                                   false,
+                                                                   [])
         example_node = Tree::TreeNode.new(SecureRandom.hex, ReportPortal.current_scenario)
         if example_node.nil?
           p "Example node is nil for scenario #{ReportPortal.current_scenario.inspect}"
diff --git a/lib/report_portal/settings.rb b/lib/report_portal/settings.rb
index a4e698b..56edb44 100644
--- a/lib/report_portal/settings.rb
+++ b/lib/report_portal/settings.rb
@@ -5,8 +5,10 @@ module ReportPortal
   class Settings
     include Singleton
 
+    PREFIX = 'rp_'
+
     def initialize
-      filename = ENV.fetch('rp_config') do
+      filename = ENV.fetch("#{PREFIX}config") do
         glob = Dir.glob('{,.config/,config/}report{,-,_}portal{.yml,.yaml}')
         p "Multiple configuration files found for ReportPortal. Using the first one: #{glob.first}" if glob.size > 1
         glob.first
@@ -22,19 +24,16 @@ module ReportPortal
         'tags' => false,
         'is_debug' => false,
         'disable_ssl_verification' => false,
-        # for parallel execution only
         'use_standard_logger' => false,
         'launch_id' => false,
-        'file_with_launch_id' => false
+        'file_with_launch_id' => false,
+        'launch_uuid' => false,
+        'log_level' => false
       }
 
       keys.each do |key, is_required|
         define_singleton_method(key.to_sym) { setting(key) }
-        next unless is_required && public_send(key).nil?
-
-        env_variable_name = env_variable_name(key)
-        raise "ReportPortal: Define environment variable '#{env_variable_name.upcase}', '#{env_variable_name}' "\
-          "or key #{key} in the configuration YAML file"
+        fail "ReportPortal: Define environment variable '#{PREFIX}#{key}' or key #{key} in the configuration YAML file" if is_required && public_send(key).nil?
       end
     end
 
@@ -46,19 +45,15 @@ module ReportPortal
       setting('formatter_modes') || []
     end
 
+    def project_url
+      "#{endpoint}/#{project}"
+    end
+
     private
 
     def setting(key)
-      env_variable_name = env_variable_name(key)
-      return YAML.safe_load(ENV[env_variable_name.upcase]) if ENV.key?(env_variable_name.upcase)
-
-      return YAML.safe_load(ENV[env_variable_name]) if ENV.key?(env_variable_name)
-
-      @properties[key]
-    end
-
-    def env_variable_name(key)
-      'rp_' + key
+      pkey = PREFIX + key
+      ENV.key?(pkey) ? YAML.load(ENV[pkey]) : @properties[key]
     end
   end
 end
diff --git a/lib/report_portal/tasks.rb b/lib/report_portal/tasks.rb
index 9acb5ba..8b025eb 100644
--- a/lib/report_portal/tasks.rb
+++ b/lib/report_portal/tasks.rb
@@ -4,22 +4,21 @@ require 'tempfile'
 require_relative '../reportportal'
 
 namespace :reportportal do
-  desc 'Start launch in Report Portal and print its id to $stdout (for use with attach_to_launch formatter mode)'
+  desc 'Start launch in Report Portal and print its id to $stdout (needed for use with ReportPortal::Cucumber::AttachToLaunchFormatter)'
   task :start_launch do
-    description = ENV['description'] || ReportPortal::Settings.instance.description
-    file_to_write_launch_id = ENV['file_for_launch_id'] || ReportPortal::Settings.instance.file_with_launch_id
-    file_to_write_launch_id ||= Pathname(Dir.tmpdir) + 'rp_launch_id.tmp'
+    description = ENV['description']
+    file_to_write_launch_id = ENV.fetch('file_for_launch_id') { Pathname(Dir.tmpdir) + 'rp_launch_id.tmp' }
     launch_id = ReportPortal.start_launch(description)
     File.write(file_to_write_launch_id, launch_id)
     puts launch_id
   end
 
-  desc 'Finish launch in Report Portal (for use with attach_to_launch formatter mode)'
+  desc 'Finish launch in Report Portal (needed for use with ReportPortal::Cucumber::AttachToLaunchFormatter)'
   task :finish_launch do
-    launch_id = ENV['launch_id'] || ReportPortal::Settings.instance.launch_id
-    file_with_launch_id = ENV['file_with_launch_id'] || ReportPortal::Settings.instance.file_with_launch_id
-    puts "Launch id isn't provided. Provide it either via RP_LAUNCH_ID or RP_FILE_WITH_LAUNCH_ID environment variables" if !launch_id && !file_with_launch_id
-    puts 'Both RP_LAUNCH_ID and RP_FILE_WITH_LAUNCH_ID are provided via environment variables' if launch_id && file_with_launch_id
+    launch_id = ENV['launch_id']
+    file_with_launch_id = ENV['file_with_launch_id']
+    puts "Launch id isn't provided. Provide it either via launch_id or file_with_launch_id environment variables" if !launch_id && !file_with_launch_id
+    puts "Both launch_id and file_with_launch_id are present in environment variables" if launch_id && file_with_launch_id
     ReportPortal.launch_id = launch_id || File.read(file_with_launch_id)
     ReportPortal.close_child_items(nil)
     ReportPortal.finish_launch
diff --git a/lib/report_portal/version.rb b/lib/report_portal/version.rb
index 27febf7..13ac7d5 100644
--- a/lib/report_portal/version.rb
+++ b/lib/report_portal/version.rb
@@ -1,3 +1,3 @@
 module ReportPortal
-  VERSION = '0.7'.freeze
+  VERSION = '1.0'
 end
diff --git a/lib/reportportal.rb b/lib/reportportal.rb
index c7a4779..3f5b5e0 100644
--- a/lib/reportportal.rb
+++ b/lib/reportportal.rb
@@ -1,26 +1,26 @@
-require 'base64'
-require 'cgi'
-require 'http'
 require 'json'
-require 'mime/types'
+require 'uri'
 require 'pathname'
 require 'tempfile'
-require 'uri'
+require 'faraday'
 
-require_relative 'report_portal/event_bus'
-require_relative 'report_portal/models/item_search_options'
-require_relative 'report_portal/models/test_item'
+require_relative 'report_portal/patches/faraday'
 require_relative 'report_portal/settings'
-require_relative 'report_portal/http_client'
+require_relative 'report_portal/client'
 
 module ReportPortal
-  LOG_LEVELS = { error: 'ERROR', warn: 'WARN', info: 'INFO', debug: 'DEBUG', trace: 'TRACE', fatal: 'FATAL', unknown: 'UNKNOWN' }.freeze
-
+  TestItem = Struct.new(:name, :type, :id, :start_time, :description, :closed, :tags)
+  LOG_LEVELS = { error: 'ERROR', warn: 'WARN', info: 'INFO', debug: 'DEBUG', trace: 'TRACE', fatal: 'FATAL', unknown: 'UNKNOWN' }
   class << self
-    attr_accessor :launch_id, :current_scenario
+    attr_accessor :launch_id, :current_scenario, :last_used_time, :logger
+
+    def initialize(logger)
+      @logger = logger
+      @client = ReportPortal::Client.new(logger)
+    end
 
     def now
-      (current_time.to_f * 1000).to_i
+      (Time.now.to_f * 1000).to_i
     end
 
     def status_to_level(status)
@@ -38,26 +38,36 @@ module ReportPortal
 
     def start_launch(description, start_time = now)
       data = { name: Settings.instance.launch, start_time: start_time, tags: Settings.instance.tags, description: description, mode: Settings.instance.launch_mode }
-      @launch_id = send_request(:post, 'launch', json: data)['id']
+      @launch_id = @client.process_request('launch', :post, data.to_json)['id']
+    end
+
+    def remote_launch
+      @client.process_request("launch/#{@launch_id}", :get)
+    end
+
+    def update_launch(data)
+      @client.process_request("launch/#{@launch_id}/update", :put, data.to_json)
     end
 
     def finish_launch(end_time = now)
+      logger.debug "finish_launch: [#{end_time}]"
       data = { end_time: end_time }
-      send_request(:put, "launch/#{@launch_id}/finish", json: data)
+      @client.process_request("launch/#{@launch_id}/finish", :put, data.to_json)
     end
 
     def start_item(item_node)
-      path = 'item'
-      path += "/#{item_node.parent.content.id}" unless item_node.parent&.is_root?
       item = item_node.content
       data = { start_time: item.start_time, name: item.name[0, 255], type: item.type.to_s, launch_id: @launch_id, description: item.description }
       data[:tags] = item.tags unless item.tags.empty?
-      event_bus.broadcast(:prepare_start_item_request, request_data: data)
-      send_request(:post, path, json: data)['id']
+      url = 'item'
+      url += "/#{item_node.parent.content.id}" unless item_node.parent && item_node.parent.is_root?
+      @client.process_request(url, :post, data.to_json)['id']
     end
 
     def finish_item(item, status = nil, end_time = nil, force_issue = nil)
-      unless item.nil? || item.id.nil? || item.closed
+      if item.nil? || item.id.nil? || item.closed
+        logger.debug 'finish_item: Item details are missing or already closed'
+      else
         data = { end_time: end_time.nil? ? now : end_time }
         data[:status] = status unless status.nil?
         if force_issue && status != :passed # TODO: check for :passed status is probably not needed
@@ -65,7 +75,14 @@ module ReportPortal
         elsif status == :skipped
           data[:issue] = { issue_type: 'NOT_ISSUE' }
         end
-        send_request(:put, "item/#{item.id}", json: data)
+        logger.debug "finish_item:id[#{item}], data: #{data} "
+        begin
+          response = @client.process_request("item/#{item.id}", :put, data.to_json)
+          logger.debug "finish_item: response [#{response}] "
+        rescue RestClient::Exception => e
+          response = JSON.parse(e.response)
+          raise e unless response['error_code'] == 40_018
+        end
         item.closed = true
       end
     end
@@ -73,84 +90,78 @@ module ReportPortal
     # TODO: implement force finish
 
     def send_log(status, message, time)
+      @logger.debug "send_log: [#{status}],[#{message}], #{@current_scenario} "
       unless @current_scenario.nil? || @current_scenario.closed # it can be nil if scenario outline in expand mode is executed
         data = { item_id: @current_scenario.id, time: time, level: status_to_level(status), message: message.to_s }
-        send_request(:post, 'log', json: data)
+        @client.process_request('log', :post, data.to_json)
       end
     end
 
-    def send_file(status, path_or_src, label = nil, time = now, mime_type = 'image/png')
-      str_without_nils = path_or_src.to_s.gsub("\0", '') # file? does not allow NULLs inside the string
-      if File.file?(str_without_nils)
-        send_file_from_path(status, path_or_src, label, time)
-      else
+    def send_file(status, path, label = nil, time = now, mime_type = 'image/png')
+      unless File.file?(path)
         if mime_type =~ /;base64$/
           mime_type = mime_type[0..-8]
-          path_or_src = Base64.decode64(path_or_src)
+          path = Base64.decode64(path)
         end
         extension = ".#{MIME::Types[mime_type].first.extensions.first}"
-        Tempfile.open(['report_portal', extension]) do |tempfile|
-          tempfile.binmode
-          tempfile.write(path_or_src)
-          tempfile.rewind
-          send_file_from_path(status, tempfile.path, label, time)
-        end
+        temp = Tempfile.open(['file', extension])
+        temp.binmode
+        temp.write(path)
+        temp.rewind
+        path = temp
       end
-    end
-
-    # @option options [Hash] options, see ReportPortal::ItemSearchOptions
-    def get_items(filter_options = {})
-      page_size = 100
-      max_pages = 100
-      all_items = []
-      1.step.each do |page_number|
-        raise 'Too many pages with the results were returned' if page_number > max_pages
-
-        options = ItemSearchOptions.new({ page_size: page_size, page_number: page_number }.merge(filter_options))
-        page_items = send_request(:get, 'item', params: options.query_params)['content'].map do |item_params|
-          TestItem.new(item_params)
-        end
-        all_items += page_items
-        break if page_items.size < page_size
+      file_name = File.basename(path)
+      label ||= file_name
+      json = { level: status_to_level(status),
+               message: label,
+               item_id: @current_scenario.id,
+               time: time,
+               file: { name: file_name.to_s },
+               "Content-Type": 'application/json' }
+      payload = { 'json_request_part': [json].to_json,
+                  file_name => Faraday::UploadIO.new(path, mime_type) }
+      @client.process_request('log', :post, payload, content_type: 'multipart/form-data')
+    end
+
+    def get_item(name, parent_node)
+      if parent_node.is_root? # folder without parent folder
+        url = "item?filter.eq.launch=#{@launch_id}&filter.eq.name=#{URI.escape(name)}&filter.size.path=0"
+      else
+        url = "item?filter.eq.launch=#{@launch_id}&filter.eq.parent=#{parent_node.content.id}&filter.eq.name=#{URI.escape(name)}"
       end
-      all_items
+      @client.process_request(url, :get)
     end
 
-    # @param item_ids [Array<String>] an array of items to remove (represented by ids)
-    def delete_items(item_ids)
-      send_request(:delete, 'item', params: { ids: item_ids })
+    def remote_item(item_id)
+      @client.process_request("item/#{item_id}", :get)
     end
 
-    # needed for parallel formatter
     def item_id_of(name, parent_node)
-      path = if parent_node.is_root? # folder without parent folder
-               "item?filter.eq.launch=#{@launch_id}&filter.eq.name=#{CGI.escape(name)}&filter.size.path=0"
-             else
-               "item?filter.eq.parent=#{parent_node.content.id}&filter.eq.name=#{CGI.escape(name)}"
-             end
-      data = send_request(:get, path)
+      data = get_item(name, parent_node)
       if data.key? 'content'
         data['content'].empty? ? nil : data['content'][0]['id']
+      else
+        nil # item isn't started yet
       end
     end
 
-    # needed for parallel formatter
     def close_child_items(parent_id)
-      path = if parent_id.nil?
-               "item?filter.eq.launch=#{@launch_id}&filter.size.path=0&page.page=1&page.size=100"
-             else
-               "item?filter.eq.parent=#{parent_id}&page.page=1&page.size=100"
-             end
+      logger.debug "closing child items: #{parent_id} "
+      if parent_id.nil?
+        url = "item?filter.eq.launch=#{@launch_id}&filter.size.path=0&page.page=1&page.size=100"
+      else
+        url = "item?filter.eq.launch=#{@launch_id}&filter.eq.parent=#{parent_id}&page.page=1&page.size=100"
+      end
       ids = []
       loop do
-        data = send_request(:get, path)
-        if data.key?('links')
-          link = data['links'].find { |i| i['rel'] == 'next' }
+        response = @client.process_request(url, :get)
+        if response.key?('links')
+          link = response['links'].find { |i| i['rel'] == 'next' }
           url = link.nil? ? nil : link['href']
         else
           url = nil
         end
-        data['content'].each do |i|
+        response['content'].each do |i|
           ids << i['id'] if i['has_childs'] && i['status'] == 'IN_PROGRESS'
         end
         break if url.nil?
@@ -158,46 +169,9 @@ module ReportPortal
 
       ids.each do |id|
         close_child_items(id)
-        finish_item(TestItem.new(id: id))
+        # temporary, we actually only need the id
+        finish_item(TestItem.new(nil, nil, id, nil, nil, nil, nil))
       end
     end
-
-    # Registers an event. The proc will be called back with the event object.
-    def on_event(name, &proc)
-      event_bus.on(name, &proc)
-    end
-
-    private
-
-    def send_file_from_path(status, path, label, time)
-      File.open(File.realpath(path), 'rb') do |file|
-        filename = File.basename(file)
-        json = [{ level: status_to_level(status), message: label || filename, item_id: @current_scenario.id, time: time, file: { name: filename } }]
-        form = {
-          json_request_part: HTTP::FormData::Part.new(JSON.dump(json), content_type: 'application/json'),
-          binary_part: HTTP::FormData::File.new(file, filename: filename)
-        }
-        send_request(:post, 'log', form: form)
-      end
-    end
-
-    def send_request(verb, path, options = {})
-      http_client.send_request(verb, path, options)
-    end
-
-    def http_client
-      @http_client ||= HttpClient.new
-    end
-
-    def current_time
-      # `now_without_mock_time` is provided by Timecop and returns a real, not mocked time
-      return Time.now_without_mock_time if Time.respond_to?(:now_without_mock_time)
-
-      Time.now
-    end
-
-    def event_bus
-      @event_bus ||= EventBus.new
-    end
   end
 end
diff --git a/reportportal.gemspec b/reportportal.gemspec
index eff01bb..e645d8a 100644
--- a/reportportal.gemspec
+++ b/reportportal.gemspec
@@ -1,4 +1,4 @@
-lib = File.expand_path('lib', __dir__)
+lib = File.expand_path('../lib', __FILE__)
 $LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)
 require 'report_portal/version'
 
@@ -14,9 +14,11 @@ Gem::Specification.new do |s|
   s.required_ruby_version  = '>= 2.3.0'
   s.license                = 'Apache-2.0'
 
-  s.add_dependency('http', '~> 4.0')
-  s.add_dependency('mime-types')
-  s.add_dependency('rubytree', '>=0.9.3')
+  s.add_dependency('net-http-persistent', '~> 3.0')
+  s.add_runtime_dependency('faraday', '~> 0.15')
+  s.add_runtime_dependency('parallel_tests', '~> 2.15')
+  s.add_runtime_dependency('rubytree', '~> 1.0')
+  s.add_runtime_dependency('sys-proctable', '1.1.5')
 
   s.add_development_dependency('rubocop', '0.71')
 end
diff --git a/tests/features/step_definitions/steps.rb b/tests/features/step_definitions/steps.rb
index 89ff183..beae36a 100644
--- a/tests/features/step_definitions/steps.rb
+++ b/tests/features/step_definitions/steps.rb
@@ -3,7 +3,7 @@ When(/^Passing step #(\d+)$/) do |num|
 end
 
 When(/^Failing step #(\d+)$/) do |num|
-  raise "Step #{num} failed"
+  fail "Step #{num} failed"
 end
 
 When(/^Passing step with table:$/) do |_table|
@@ -12,11 +12,10 @@ end
 
 When(/^Step that fails on every second execution$/) do
   if $odd_even.odd?
-    raise "Step failed at iteration #{$odd_even}"
+    fail "Step failed at iteration #{$odd_even}"
   else
     puts "Step passed at iteration #{$odd_even}"
   end
-
   $odd_even_started = true
 end
 
@@ -28,6 +27,6 @@ When(/^Step with multiline string$/) do |str|
   puts "Step with multiline string #{str}"
 end
 
-When(/^Step with failing AfterStep hook$/) do
+When (/^Step with failing AfterStep hook$/) do
   @invoke_after_step = true
 end
diff --git a/tests/features/support/env.rb b/tests/features/support/env.rb
index cc741ff..7105ddb 100644
--- a/tests/features/support/env.rb
+++ b/tests/features/support/env.rb
@@ -1,21 +1,15 @@
-require 'base64'
 require 'cucumber'
 require 'pathname'
 
-file_path = Pathname(__dir__).parent.parent + 'assets' + 'crane.png'
+$odd_even = 0
+$odd_even_started = false
 
-After('@file_via_path') do
-  embed file_path, 'image/png', 'Image'
-end
-
-After('@file_via_src') do
-  src = File.read(file_path, mode: 'rb')
-  embed src, 'image/png', 'Image'
-end
-
-After('@file_via_base64_src') do
-  base64_src = Base64.encode64(File.read(file_path, mode: 'rb'))
-  embed base64_src, 'image/png;base64', 'Image'
+After do |scenario|
+  $odd_even += 1 if $odd_even_started
+  if scenario.failed?
+    image = Pathname(__FILE__).dirname.parent.parent + 'assets' + 'crane.png'
+    embed image, 'image/png', 'Failure screenshot'
+  end
 end
 
 Before('@pass_before') do
@@ -27,11 +21,11 @@ After('@pass_after') do
 end
 
 Before('@fail_before') do
-  raise 'Failure in before hook'
+  fail 'Failure in before hook'
 end
 
 After('@fail_after') do
-  raise 'Failure in after hook'
+  fail 'Failure in after hook'
 end
 
 Before do
@@ -44,29 +38,6 @@ end
 
 AfterStep do
   if @invoke_after_step
-    raise 'I failed!'
-  end
-end
-
-AfterConfiguration do |config|
-  config.on_event :test_run_started do
-    ReportPortal.on_event :prepare_start_item_request do |rp_event|
-      rp_event.request_data[:parameters] = [{ key: 'param_name', value: 'param_value' }]
-    end
-    ReportPortal.on_event :prepare_start_item_request do |rp_event|
-      rp_event.request_data[:parameters] << { key: 'param_name2', value: 'param_value2' }
-    end
+    fail 'I failed!'
   end
 end
-
-at_exit do
-  items = ReportPortal.get_items(launch_id: ReportPortal.launch_id, name: 'Scenario Outline: Conditionally passing outline, Examples (#1)')
-  raise "Incorrect items: #{items}" if items.size != 1
-  raise "Incorrect items: #{items}" if items[0].description != 'tests/features/without_background.feature:108'
-
-  ReportPortal.delete_items(items.map(&:id))
-  items = ReportPortal.get_items(launch_id: ReportPortal.launch_id, name: 'Scenario Outline: Conditionally passing outline, Examples (#1)')
-  raise 'Item is not deleted' unless items.empty?
-
-  puts 'at_exit hook completed successfully'
-end
diff --git a/tests/features/without_background.feature b/tests/features/without_background.feature
index 73687c5..b0a3f9c 100644
--- a/tests/features/without_background.feature
+++ b/tests/features/without_background.feature
@@ -204,15 +204,3 @@ Feature: Scenarios without background
     | don't like    |
     | hate          |
     | despise       |
-
-  @file_via_path
-  Scenario: With a file passed using a path
-    Given Passing step #1
-
-  @file_via_src
-  Scenario: With a file passed using source
-    Given Passing step #1
-
-  @file_via_base64_src
-  Scenario: With a file passed using base64 source
-    Given Passing step #1
diff --git a/tests/formatter_spec.rb b/tests/formatter_spec.rb
new file mode 100644
index 0000000..88d4b9d
--- /dev/null
+++ b/tests/formatter_spec.rb
@@ -0,0 +1,52 @@
+require 'rspec'
+require_relative '../lib/formatter/report_portal'
+
+def name
+  "Name #{Time.now}"
+end
+
+describe ReportPortal do
+  require_relative '../lib/settings'
+
+  let(:report_portal) { ReportPortal.new(nil, IO, {:file => File.join('..', 'config', 'report_portal.yaml')}) }
+
+  it 'should create launch' do
+    id = report_portal.before_features(nil)
+    expect(id).to_not be_nil
+    report_portal.after_features(nil)
+  end
+
+  context 'launch created' do
+    require_relative '../lib/models/test_item'
+
+    before(:each) do
+      report_portal.before_features(nil)
+    end
+
+    after(:each) do
+      report_portal.after_features(nil)
+    end
+
+    context 'feature created' do
+      before(:each) do
+        report_portal.feature_name('Feature', name)
+      end
+
+      after(:each) do
+        report_portal.after_feature(nil)
+      end
+
+      context 'scenario created' do
+        before(:each) { report_portal.scenario_name('Scenario', name, "#{__FILE__} #{__LINE__}", nil) }
+
+        it 'should be allow to close as skipped' do
+          step_match = double('StepMatch')
+          allow(step_match).to receive(:format_args).and_return(name)
+          report_portal.step_name('Step', step_match, nil, nil, nil, "#{__FILE__} #{__LINE__}")
+          sleep 3
+          report_portal.after_step_result('Step', step_match, nil, :skipped, nil, nil, nil, nil)
+        end
+      end
+    end
+  end
+end
diff --git a/tests/spec/test_spec.rb b/tests/spec/test_spec.rb
index 0367332..9a8a119 100644
--- a/tests/spec/test_spec.rb
+++ b/tests/spec/test_spec.rb
@@ -9,12 +9,12 @@ RSpec.describe 'top level', :ui do
   end
 
   it 'fails' do
-    raise 'error'
+    fail 'error'
   end
 
   it 'is pending' do
     pending('reason 1')
-    raise 'error to make it failed as expected'
+    fail 'error to make it failed as expected'
   end
 
   it 'marked as pending but actually it passes' do
@@ -27,7 +27,7 @@ RSpec.describe 'top level', :ui do
 
     context 'nested context' do
       it 'is nested twice' do
-        raise 'error'
+        fail 'error'
       end
     end
   end
